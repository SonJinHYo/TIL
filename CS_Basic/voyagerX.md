# voygerX

## 기술 질문

### PNG, JPG
#### JPG (Joint Photographic Experts Group)
- 정지 영상 데이터 압축 형식
- jpeg와 jpg는 같다. 이전에는 확장자 표시가 3문자였기에 그 좀 더 줄여쓴것이 jpg
- Windows에서는 파일 확장자의 대소문자를 식별하지 않지만, UNIX 에서는 구별을 하므로 다르게 인식될 수 있다.
#### PNG (Portable Network Graphics
- jpg에서 투명 백그라운드를 지원. 때문에 크기는 jpg보다 커진다.
- PNG-8, PNG-24 두 종류가 있으며 24에서 더 고화질의 표현이 가능
- 화질 손상 방지를 위해 압축률이 낮다. 
#### 장단점
- jpg는 손실 압축을 하기 때문에 크기가 작지만 원본 데이터의 손실이 일어나고, PNG는 비손실 압축으로 크기가 크고 손실 없는 원본 데이터를 얻을 수 있다.
- 파이썬으로 데이터를 불러올 시 jpg의 깊이는 3, png의 경우 4가 된다.


### Dynamic Programing
- 복잡한 문제를 간단한 여러 개의 문제롤 나누어 푸는 방법.
- 알고리즘 문제로 풀기 위한 조건
  1. 겹치는 부분 문제
  2. 최적 부분 구조
- 최단 경로 문제, 행렬 제곱 문제 등 최적화에 사용. **모든 방법을 검토**한다.
- greedy algorithm과의 차이는
  - 모든 방법을 탐색하지 않는다.
  - 항상 최적해를 구하지 않는다.
  - 시간대비 효율적인 해를 구할 수 있다.
- divide & conquer과의
  - 공통점 : 주어진 문제를 하위 문제로 나누어 해결하고 연계적으로 해결
  - 차이점 : 하위 문제가 중복해서 일어나지 않는 상황에선 divide & conquer


### Virtual Memory
####Memory
- 데이터 및 코드를 저장하는 장치
- 주기억장치 : 내부 기억장치 (register, cache memory)
- 보조기억장치 : 외부 기억장치 (SSD, HDD)
#### virtual memory
- 등장배경: (초기 컴퓨터 시절) RAM 용량보다 APP용량이 더 커서 메모리가 부족
- 오버레이 기법 : APP의 일부분만 메모리에 올려 실행
  - 메모리 사용만 좀 덜 하고 결국 메모리 부족 오류는 발생
- 가상메모리 기법 : APP을 실행하는데 필요한 **최소한** 얼마만큼의 메모리가 필요한가에 집중
  - 메모리 접근은 순차적이고 지역화되어 있기 때문
  - 일부분만 **주기억장치** -> 나머지는  RAM의 **보조기억장치** 에 메모리를 올린다.
    - **빠르고 작은 RAM + 느리고 큰 DISK와 결합**


### Semaphore
- 여러 프로세스가 동시에 접근할 때 충돌을 방지하는 동기화 방식(Mutwx, Semaphore)
- Critical Section : 여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 블록
- Mutex : 공유 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘
  - 임계구역을 가진 스레드들의 실행시간이 소러 겹치지 않고 각각 단독으로 실행되도록 하는 기술
  - 프로세스가 가진 Key를 기반으로 스레드/프로세스의 자원에 접근 허용 (상호배제 기법)
- Semaphore : 멀티 프로그래밍 환경에서 공유된 자원애 대한 접근을 제한하는 방법
  - 공유자원의 상태를 나타낼 수 있는 카운터로 생각할 때,
    - 사용하고 있는 스레드/프로세스의 수를 공통으로 관리하는 하나의 값을 이용해 상호배제를 달성
    - 운영체제 또는 커널의 한 지정된 저장장치 내의 값
    - 일반적으로 비교적 긴 시간을 확보하는 리소스에 대한 이용
  - 공유 자원에 접근할 수 있는 프로세스의 최대 허용치만큼 동시에 사용자가 접근할 수 있다.
  - 각 프로세스는 Semaphore값을 확인하고 변경 가능
  - 자원을 사용하지 않는 상태가 될 때, 대기중인 프로세스가 즉시 자원 사용
  - 이미 다른 프로세스에 의해 사용중이라는 사실을 알게 되면 재시도 전에 일정시간 대기
#### Semaphore vs Mutex
1. 동기화 대상의 갯수 : 
 - Mutex : 동기화 대상이 한 개,
 - Semaphore : 동기화 대상이 한 개 이상
2. 자원 소유 여부
 - Mutex : 0,1 상태 뿐이라 자원 소유 가능, Lock을 가짐
 - Semaphore : 자원 소유 불가능
3. 해제 여부
 - Mutex : Mutex를 소유한 스레드만이 Mutex를 해제 가능
 - Semaphore : Semaphore을 소유하지 않는 스레드가 해제 가능
4. 존재 여부
 - Mutex : 프로세스 종료 시 Clean up
 - Semaphore : 시스템 범위에 걸쳐 있고, 파일로 존재


### Cache
- 자주 사용하는 데이터, 값을 미리 복사해 놓은 임시 장소
  - 반복적으로 데이터를 불러오는 경우, 지속적으로 DBMS(Database Management system)/Server에 request하는 것이 아닌 Memory에 저장된 데이터를 가져다 사용.
- 작은 저장 장소, 비싼 비용, 빠른 성능
- ![image](https://user-images.githubusercontent.com/88013439/220815477-85154ccd-d6ec-4d1e-adc2-90f966b17b30.png)
- Long Tail 법칙(20%의 request가 시스템 리소스의 대부분을 사용한다)을 참고하여 20%에 Cache를 이용
- 캐시의 효율적 동작을 위해선 데이터가 **지역성**(데이터의 접근이 시공간적으로 가깝게 일어나는 것)을 가져야 한다.
  - 시간적 지역성 : 데이터의 접근 이후 가까운 시간 내에 다시 접근할 가능성이 높은 것
  - 공간적 지역성 : 특정 데이터와 가까운 주소가 순서대로 접근되는 경우
    - CPU캐시/Disk캐시는 데이터를 접근할 때 주소뿐 아니라 블록 전체 캐시를 가져옴. 이 때 메모리가 오름/내림차순으로 접근된다면 블록 내에서 모두 접근 가능
 
 
 ### Garbage Collection (GC)
- 메모리 관리 기법. 동적 할당이 된 메모리 영역 중에서 필요없게 된 영역을 자동으로 탐지하여 해제하는 기능
- 장점
  - 프로그래머가 메모리 영역 전체를 완벽하게 관리하지 않아도 된다.
  - 유효하지 않은 포인터 접근(할당이 해제된 메모리에 접근하는 버그) 해결
  - 이중 해제 버그 오류 해결
  - 메모리 누수 : 더 이상 사용하지 않는 메모리 영역을 해제하지 않고 남겨진 것이 쌓이게 되는 현상
- 단점
  - 비용 문제 : 어떤 메모리를 해제해야 할 지 결정하는데 사용되는 알고리즘 비용. (프로그래머가 해제할 메모리를 알고 있어도 추적의 비용이 발생)
  - GC의 해동 타이밍이나 점유 시간을 사전에 예측하기 어렵기에 실시간 시스템에 적합하지 않음.
  - 할당된 메모리가 해제되는 시점을 알 수 없게 된다.
- 방식
  - 포인터 추적 방식 : 한 개 이상의 변수가 접근 가능한 메모리를 제외한 메모리를 해제하는 방식
  - Mark and sweep(MARK) : 할당받은 메모리 중 1비트를 남겨 메모리를 사용하는지 여부를 표시로 사용
    - 단, 표시 단계에서 메모리 내용이 변경되면 되지 않는다
  - 삼색 표시 기법 : MARK 기법의 단점을 보완.
  - 순서
    1. 각가그이 객체를 흰,검,회색으로 분류
      - 흰색 : 더 이상 접근이 불가능한 객체
      - 회색 : 접근 가능하지만 검사되지 않은 객체
      - 검은색 : 흰색 객체가 아님
      - 알고리즘이 시작할 때 변수가 가리키는 객체들이 회색으로 표시되며, 그 외의 모든 객체는 흰색으로 표시
    2. 회색 객체 중 하나를 선택하여 검은색으로 표시, 이 객체가 가리키는 객체는 모두 회색
    3. 회색 객체가 남지 않을 때 까지 반복
    4. 남은 흰색 객체는 접근 불가능하므로 모두 해제


### Database Index
- 효율적인 검색을 위해 데이터에 Index를 부여. (SELECT 쿼리의 WHERE에 사용할 컬럼의 효율적 검색)
- 좋은 컬럼(Index) 선정기준 4가지
  1. Cardinality : 높을수록 (컬럼의 값의 중복도가 낮을수록)
  2. Selectivity : 낮을수록 (한 컬럼이 가진 값 하나로 적은 row가 탐색) (일반적으로 5~10%가 적당)
  3. 조회 활용도 : 높을수록
  4. 수정 빈도 : 낮을수록
- (과한) Index 단점 : 전체적인 DB 성능 부하
  1. 메모리를 많이 잡아먹는다
  2. 컬럼 값 수정시 테이블 갱신으로 인해 느려질 수 있다.
  3. DML에서 INSERT, UPDATE, DELETE의 효율이 떨어짐. (다만 UPDATE, DELETE는 찾는 속도가 빨라져서 큰 영향이 없을 수 있음)
- Index 장점 : 효율적이고 빠른 SELECT


### NoSQL
#### Base
- DMBS (DataBase Management System) : 사용자와 DB 사이에서 사용자의 요구에 따라 데이터를 생성 및 DB를 관리해주는 SW
- SQL (Structured Query Language) : 관계형 데이터베이스(RDB) 관리 시스템의 데이터를 관리하기 위해 설계된 언어
- RDBMS : RDB를 관리하는 시스템. 모든 데이터를 2차원 테이블 형태로 표현하는 DB
#### NoSQL
- RDBMS와 달리 테이블 간 관계를 정의하지 않음 (테이블 간 Join 불가능)
- 빅데이터의 등장으로 트래픽이 급증 => RDBMS 단점(성능) 향상을 보완하기 위해 등장
  - 데이터의 일관성을 포기
  - 비용을 고려하여, 여러 대의 데이터에 분산 저장하는 Scale-Out 목표로 등장
- 관리 기술
  1. Key-Value Database
    - 데이터가 Key-Value 쌍으로 저장이 된다.
    - Key값은 어떤 형태의 데이터라도 담을 수 있다.(이미지, 비디오 등)
    - API가 간단하여 속도가 빠름
    - 대표DB : Redis, Amazon Dynamo DB, Riak
  2. Document Database
    - Key, Document 형태로 저장
    - Value와의 차이점 : Value값이 계층적 형태의 Document로 저장 (객체와 유사. 하나의 객체를 여러 테이블에 나눠서 저장 X)
    - 객체-관계 매핑이 필요 X (객체를 Document로 저장하니까)
    - 속도가 빠르지만 사용이 번거로움
    - 대표DB : MongoDB, CouthDB
  3. Wide Column Database
    - Key값이 필드를 결정
      - Key : Row, Column-family, Column-name을 가짐
      - 연관된 데이터는 같은 Column-family에 속하고 각자의 Column-name을 가짐
      - 질의는 Row, Column-family, Column-name 으로 수행
    - 대표DB : HBase, Hypertable
  4. Graph Database
    - 데이터를 Node, Edge, Property와 함께 **그래프 구조**를 사용하는 DB
    - 데이터 간의 관계가 탐색의 Key일 경우 적합 (ex. 소셜 네트워크의 친구의 친구 찾기)
    - 대표DB : Neo4J


### 공유기(Router)
-  통신방법
  1. 클라이언트가 서버의 IP로 접속할 때, 클라이언트의 IP또한 서버로 전달
  2. 인터넷에 접속 시 (와이파이 or 유선) 해당 기기에 IP가 부여
    - 통신사와 계약하여 케이블 회선을 받아 인터넷에 접속이 가능한 기기여야함 (인터넷 사용이 가능한 모든 기기는 IP주소를 가짐)
- 사용 이유 : 하나의 IP주소를 공유할 수 있다. (기기당 통신사와 계약할 필요가 없어짐)
- 작동 원리 
  - WAN (Wide Area Network)
    - 통신사로부터 부여받은 케이블을 꽂는 단자
    - 케이블을 WAN단자에 연결하면 **통신사로부터 부여받은 IP는공유기가 차지**
    - 부여받은 IP는 전세계 어디서든 접근 가능한 IP가 된다. **public IP address(공용IP)**라고 부름
  - LAN (Local Area Network)
    - 하나의 인터넷 케이블로 여러 기기들을 유선/무선으로 연결할 수 있는 단자
    - LAN으로 연결된 기기들은 IP를 부여받고, 공유기도 해당 IP를 받음. 공유기는 2개의 IP를 가짐
    - 받는 주소가 private IP address(사설IP). 외부에서 바로 접속 불가능
      - 192.168.~.~ 가 사설IP
      - 공용IP는 중복X, 사설IP는 중복 가능

