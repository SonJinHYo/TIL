# voygerX

## 기술 질문

### PNG, JPG
#### JPG (Joint Photographic Experts Group)
- 정지 영상 데이터 압축 형식
- jpeg와 jpg는 같다. 이전에는 확장자 표시가 3문자였기에 그 좀 더 줄여쓴것이 jpg
- Windows에서는 파일 확장자의 대소문자를 식별하지 않지만, UNIX 에서는 구별을 하므로 다르게 인식될 수 있다.
#### PNG (Portable Network Graphics
- jpg에서 투명 백그라운드를 지원. 때문에 크기는 jpg보다 커진다.
- PNG-8, PNG-24 두 종류가 있으며 24에서 더 고화질의 표현이 가능
- 화질 손상 방지를 위해 압축률이 낮다. 
#### 장단점
- jpg는 손실 압축을 하기 때문에 크기가 작지만 원본 데이터의 손실이 일어나고, PNG는 비손실 압축으로 크기가 크고 손실 없는 원본 데이터를 얻을 수 있다.
- 파이썬으로 데이터를 불러올 시 jpg의 깊이는 3, png의 경우 4가 된다.


### Dynamic Programing
- 복잡한 문제를 간단한 여러 개의 문제롤 나누어 푸는 방법.
- 알고리즘 문제로 풀기 위한 조건
  1. 겹치는 부분 문제
  2. 최적 부분 구조
- 최단 경로 문제, 행렬 제곱 문제 등 최적화에 사용. **모든 방법을 검토**한다.
- greedy algorithm과의 차이는
  - 모든 방법을 탐색하지 않는다.
  - 항상 최적해를 구하지 않는다.
  - 시간대비 효율적인 해를 구할 수 있다.
- divide & conquer과의
  - 공통점 : 주어진 문제를 하위 문제로 나누어 해결하고 연계적으로 해결
  - 차이점 : 하위 문제가 중복해서 일어나지 않는 상황에선 divide & conquer


### Virtual Memory
####Memory
- 데이터 및 코드를 저장하는 장치
- 주기억장치 : 내부 기억장치 (register, cache memory)
- 보조기억장치 : 외부 기억장치 (SSD, HDD)
#### virtual memory
- 등장배경: (초기 컴퓨터 시절) RAM 용량보다 APP용량이 더 커서 메모리가 부족
- 오버레이 기법 : APP의 일부분만 메모리에 올려 실행
  - 메모리 사용만 좀 덜 하고 결국 메모리 부족 오류는 발생
- 가상메모리 기법 : APP을 실행하는데 필요한 **최소한** 얼마만큼의 메모리가 필요한가에 집중
  - 메모리 접근은 순차적이고 지역화되어 있기 때문
  - 일부분만 **주기억장치** -> 나머지는  RAM의 **보조기억장치** 에 메모리를 올린다.
    - **빠르고 작은 RAM + 느리고 큰 DISK와 결합**


### Semaphore
- 여러 프로세스가 동시에 접근할 때 충돌을 방지하는 동기화 방식(Mutwx, Semaphore)
- Critical Section : 여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 블록
- Mutex : 공유 불가능한 자원의 동시 사용을 피하기 위해 사용하는 알고리즘
  - 임계구역을 가진 스레드들의 실행시간이 소러 겹치지 않고 각각 단독으로 실행되도록 하는 기술
  - 프로세스가 가진 Key를 기반으로 스레드/프로세스의 자원에 접근 허용 (상호배제 기법)
- Semaphore : 멀티 프로그래밍 환경에서 공유된 자원애 대한 접근을 제한하는 방법
  - 공유자원의 상태를 나타낼 수 있는 카운터로 생각할 때,
    - 사용하고 있는 스레드/프로세스의 수를 공통으로 관리하는 하나의 값을 이용해 상호배제를 달성
    - 운영체제 또는 커널의 한 지정된 저장장치 내의 값
    - 일반적으로 비교적 긴 시간을 확보하는 리소스에 대한 이용
  - 공유 자원에 접근할 수 있는 프로세스의 최대 허용치만큼 동시에 사용자가 접근할 수 있다.
  - 각 프로세스는 Semaphore값을 확인하고 변경 가능
  - 자원을 사용하지 않는 상태가 될 때, 대기중인 프로세스가 즉시 자원 사용
  - 이미 다른 프로세스에 의해 사용중이라는 사실을 알게 되면 재시도 전에 일정시간 대기
#### Semaphore vs Mutex
1. 동기화 대상의 갯수 : 
 - Mutex : 동기화 대상이 한 개,
 - Semaphore : 동기화 대상이 한 개 이상
2. 자원 소유 여부
 - Mutex : 0,1 상태 뿐이라 자원 소유 가능, Lock을 가짐
 - Semaphore : 자원 소유 불가능
3. 해제 여부
 - Mutex : Mutex를 소유한 스레드만이 Mutex를 해제 가능
 - Semaphore : Semaphore을 소유하지 않는 스레드가 해제 가능
4. 존재 여부
 - Mutex : 프로세스 종료 시 Clean up
 - Semaphore : 시스템 범위에 걸쳐 있고, 파일로 존재


### Cache
- 자주 사용하는 데이터, 값을 미리 복사해 놓은 임시 장소
  - 반복적으로 데이터를 불러오는 경우, 지속적으로 DBMS(Database Management system)/Server에 request하는 것이 아닌 Memory에 저장된 데이터를 가져다 사용.
- 작은 저장 장소, 비싼 비용, 빠른 성능
- ![image](https://user-images.githubusercontent.com/88013439/220815477-85154ccd-d6ec-4d1e-adc2-90f966b17b30.png)
- Long Tail 법칙(20%의 request가 시스템 리소스의 대부분을 사용한다)을 참고하여 20%에 Cache를 이용
- 캐시의 효율적 동작을 위해선 데이터가 **지역성**(데이터의 접근이 시공간적으로 가깝게 일어나는 것)을 가져야 한다.
  - 시간적 지역성 : 데이터의 접근 이후 가까운 시간 내에 다시 접근할 가능성이 높은 것
  - 공간적 지역성 : 특정 데이터와 가까운 주소가 순서대로 접근되는 경우
    - CPU캐시/Disk캐시는 데이터를 접근할 때 주소뿐 아니라 블록 전체 캐시를 가져옴. 이 때 메모리가 오름/내림차순으로 접근된다면 블록 내에서 모두 접근 가능
 
 
 ### Garbage Collection (GC)
- 메모리 관리 기법. 동적 할당이 된 메모리 영역 중에서 필요없게 된 영역을 자동으로 탐지하여 해제하는 기능
- 장점
  - 프로그래머가 메모리 영역 전체를 완벽하게 관리하지 않아도 된다.
  - 유효하지 않은 포인터 접근(할당이 해제된 메모리에 접근하는 버그) 해결
  - 이중 해제 버그 오류 해결
  - 메모리 누수 : 더 이상 사용하지 않는 메모리 영역을 해제하지 않고 남겨진 것이 쌓이게 되는 현상
- 단점
  - 비용 문제 : 어떤 메모리를 해제해야 할 지 결정하는데 사용되는 알고리즘 비용. (프로그래머가 해제할 메모리를 알고 있어도 추적의 비용이 발생)
  - GC의 해동 타이밍이나 점유 시간을 사전에 예측하기 어렵기에 실시간 시스템에 적합하지 않음.
  - 할당된 메모리가 해제되는 시점을 알 수 없게 된다.
- 방식
  - 포인터 추적 방식 : 한 개 이상의 변수가 접근 가능한 메모리를 제외한 메모리를 해제하는 방식
  - Mark and sweep(MARK) : 할당받은 메모리 중 1비트를 남겨 메모리를 사용하는지 여부를 표시로 사용
    - 단, 표시 단계에서 메모리 내용이 변경되면 되지 않는다
  - 삼색 표시 기법 : MARK 기법의 단점을 보완.
  - 순서
    1. 각가그이 객체를 흰,검,회색으로 분류
      - 흰색 : 더 이상 접근이 불가능한 객체
      - 회색 : 접근 가능하지만 검사되지 않은 객체
      - 검은색 : 흰색 객체가 아님
      - 알고리즘이 시작할 때 변수가 가리키는 객체들이 회색으로 표시되며, 그 외의 모든 객체는 흰색으로 표시
    2. 회색 객체 중 하나를 선택하여 검은색으로 표시, 이 객체가 가리키는 객체는 모두 회색
    3. 회색 객체가 남지 않을 때 까지 반복
    4. 남은 흰색 객체는 접근 불가능하므로 모두 해제


### Database Index
- 효율적인 검색을 위해 데이터에 Index를 부여. (SELECT 쿼리의 WHERE에 사용할 컬럼의 효율적 검색)
- 좋은 컬럼(Index) 선정기준 4가지
  1. Cardinality : 높을수록 (컬럼의 값의 중복도가 낮을수록)
  2. Selectivity : 낮을수록 (한 컬럼이 가진 값 하나로 적은 row가 탐색) (일반적으로 5~10%가 적당)
  3. 조회 활용도 : 높을수록
  4. 수정 빈도 : 낮을수록
- (과한) Index 단점 : 전체적인 DB 성능 부하
  1. 메모리를 많이 잡아먹는다
  2. 컬럼 값 수정시 테이블 갱신으로 인해 느려질 수 있다.
  3. DML에서 INSERT, UPDATE, DELETE의 효율이 떨어짐. (다만 UPDATE, DELETE는 찾는 속도가 빨라져서 큰 영향이 없을 수 있음)
- Index 장점 : 효율적이고 빠른 SELECT


### NoSQL
#### Base
- DMBS (DataBase Management System) : 사용자와 DB 사이에서 사용자의 요구에 따라 데이터를 생성 및 DB를 관리해주는 SW
- SQL (Structured Query Language) : 관계형 데이터베이스(RDB) 관리 시스템의 데이터를 관리하기 위해 설계된 언어
- RDBMS : RDB를 관리하는 시스템. 모든 데이터를 2차원 테이블 형태로 표현하는 DB
#### NoSQL
- RDBMS와 달리 테이블 간 관계를 정의하지 않음 (테이블 간 Join 불가능)
- 빅데이터의 등장으로 트래픽이 급증 => RDBMS 단점(성능) 향상을 보완하기 위해 등장
  - 데이터의 일관성을 포기
  - 비용을 고려하여, 여러 대의 데이터에 분산 저장하는 Scale-Out 목표로 등장
- 관리 기술
  1. Key-Value Database
    - 데이터가 Key-Value 쌍으로 저장이 된다.
    - Key값은 어떤 형태의 데이터라도 담을 수 있다.(이미지, 비디오 등)
    - API가 간단하여 속도가 빠름
    - 대표DB : Redis, Amazon Dynamo DB, Riak
  2. Document Database
    - Key, Document 형태로 저장
    - Value와의 차이점 : Value값이 계층적 형태의 Document로 저장 (객체와 유사. 하나의 객체를 여러 테이블에 나눠서 저장 X)
    - 객체-관계 매핑이 필요 X (객체를 Document로 저장하니까)
    - 속도가 빠르지만 사용이 번거로움
    - 대표DB : MongoDB, CouthDB
  3. Wide Column Database
    - Key값이 필드를 결정
      - Key : Row, Column-family, Column-name을 가짐
      - 연관된 데이터는 같은 Column-family에 속하고 각자의 Column-name을 가짐
      - 질의는 Row, Column-family, Column-name 으로 수행
    - 대표DB : HBase, Hypertable
  4. Graph Database
    - 데이터를 Node, Edge, Property와 함께 **그래프 구조**를 사용하는 DB
    - 데이터 간의 관계가 탐색의 Key일 경우 적합 (ex. 소셜 네트워크의 친구의 친구 찾기)
    - 대표DB : Neo4J


### 공유기(Router)
-  통신방법
  1. 클라이언트가 서버의 IP로 접속할 때, 클라이언트의 IP또한 서버로 전달
  2. 인터넷에 접속 시 (와이파이 or 유선) 해당 기기에 IP가 부여
    - 통신사와 계약하여 케이블 회선을 받아 인터넷에 접속이 가능한 기기여야함 (인터넷 사용이 가능한 모든 기기는 IP주소를 가짐)
- 사용 이유 : 하나의 IP주소를 공유할 수 있다. (기기당 통신사와 계약할 필요가 없어짐)
- 작동 원리 
  - WAN (Wide Area Network)
    - 통신사로부터 부여받은 케이블을 꽂는 단자
    - 케이블을 WAN단자에 연결하면 **통신사로부터 부여받은 IP는공유기가 차지**
    - 부여받은 IP는 전세계 어디서든 접근 가능한 IP가 된다. **public IP address(공용IP)**라고 부름
  - LAN (Local Area Network)
    - 하나의 인터넷 케이블로 여러 기기들을 유선/무선으로 연결할 수 있는 단자
    - LAN으로 연결된 기기들은 IP를 부여받고, 공유기도 해당 IP를 받음. 공유기는 2개의 IP를 가짐
    - 받는 주소가 private IP address(사설IP). 외부에서 바로 접속 불가능
      - 192.168.~.~ 가 사설IP
      - 공용IP는 중복X, 사설IP는 중복 가능



### HTTP (HyperText Transfer Protocol)
- HyperText : 링크를 통해 다른 문서로 연결될 수 있는 문서
- Transfer : 를 전송하는
- Protocol : 규격이 정해진 규칙 체계
- **클라이언트(브라우저)가 웹 서버 정보를 주고받을 수 있는 프로토콜**
#### HTTP/0.9
- One-Line Protocol이라 불리고 버전 번호가 없이 발행
- GET 메서드만 존재. HTML만 전송 가능. 상태나 오류코드 X
- 서버에 연결되면 프로토콜, 서버, 포트가 불필요해져서 매우 단순
#### HTTP/1.0
- 버전 정보를 명시하기 시작
- status code 추가
- request, response에 header 개념 추가
  - 메타데이터 전송 허용
  - 유연성 및 확장성
  - Content-Type을 명시하면서 다른 타입의 문서도 전달 가능
#### HTTP/1.1
이전 버전의 모호함을 없애고 명확한 정의를 사용
- 커넥션 재사용 가능 : 기존 연결과의 최초 연결과정 생략 가능
- Pipelining 추가 : 이전 요청의 응답이 완전히 전송되기 전에 다음 요청이 가능 => 통신 대기시간 감소
- 추가적인 캐시 제어 매커니즘 도입
- Language, Encoding, Type 등을 포함한 컨텐츠 전송
- header의 **Host** Field : 동일한 IP주소에 다른 도메인을 호스트하는 기능이 가능해짐
##### HTTPS (HTTP Secure)
- TCP/IP 스택을 통해 HTTP를 전송하는 대신 **암호화된 전송 계층인 SSL**을 만듦.
- SSL(Secure Sockets Layer) 은 TLS(Transport Layer Security)로 발전. 
##### RESTful API
- 2000년에 새로운 패턴으로 등장
- 표준 규격이 없었지만 2010부터 매우 일반적으로 사용
##### HTTP/1.1 동작 원리
- HTTP/1.1 Baseline 통신 : 여러 request가 들어오면 request-response-request-response 식의 과정
- HTTP/1.1 Pipelinig 통신 : 여러 request이 들어오면 request들을 한번에 받고 response. **response순서가 request 순서와 같음**
- HTTP/1.1 Multiplexing 통신 : Pipelining 통신에서 **response순서가 request 순서와 다를 수 있음**
##### HTTP/1.1 단점
- HOL Blocking : 앞선 response가 길어지면 뒷부분도 길어진다
- RTT(Round Trip Time, 요청에 대한 응답까지의 시간) 증가 : request별로 Connection을 만들고 3-way-handshake가 반복적으로 일어나며 RTT 증가
- 무거운 Header 구조 : 많은 메타 정보, 중복된 헤더값, cookie 정보 등이 포함되며 성능이 저하
##### SPDY
- 리소스 증가, 다수의 도메인, 동적 웹페이지, 보안 등등 웹 환경의 변화 => 전송 지연
- SPDY : 전송 지연 문제 해결을 위한 새로운 프로토콜(Google). 상당한 성능 향상과 효율을 보임
- HTTP/2 초안의 규격이 됨
- 특징 (HTTP/2와 대부분 겹침)
  - 항상 TLS 위에서 동작 (HTTPS로 작성된 웹 사이트에만 적용 가능)
  - HTTP 헤더 압축 : 요청이 많아질 수록 압축률은 커지고, 모바일에서 효과가 크게 보임
  - 텍스트가 아닌 Binary Protocol : Parsing이 빠르고 오류 발생이 낮음
  - Multiplexing : 하나의 커넥션 안에서 다수의 독립적인 스트립을 동시에 처리
  - Full-duplex interleaving & Prioritization : 다름 스트림이 끼어드는 것을 허용
  - Server Push


#### HTTP/2
- HTTP/1의 확장. 기존 HTTP/1.과의 호환성을 유지하며 성능에 초점을 맞춘 프로토콜
- 특징
  - Multiplexed Streams 
    - 하나의 TCP 연결을 통해 여러 데이터 요청을 **병렬**로 전송 가능
    - Connection 한 개로 여러 개의 메세지를 주고 받을 수 있으며 응답 순서에 상관없이 Stream으로 주고받는다.
  - Header Compression
    - 중복 헤더 프레임을 압축해서 전송. (HPACK 규격 사용)
  - Binary Protocol
    - 텍스트와 공백들이 섞여 혼동이 발생하던 명령들보다 명령어를 단순하게 구현
    - 데이터 파싱이 빠르고 오류 발생이 낮아짐
    - 네트워크 리소스의 효과적 사용
    - 텍스트 특성과 관련된 보안 문제 해결
    - HTTP/2의 다른 기능(압툭 멀티플렉싱, 우선 순위 지정, 흐름 제어 등) 활성화
  - Server Push
    - 서버에 요청되지 않았지만 향후 요청에서 예상되는 추가 정보를 클라이언트에 전송할 수 있음.
      - ex. 리소스X에 대해 요청하고 리소스Y가 X파일에서 참조된다면 X,Y를 함께 push
    - 유용성
      - 클라이언트는 push된 리소스를 캐시에 저장 => 여러 페이지에 걸쳐서 캐시를 재사용
      - 서버는 Multiplexing으로 요청한 정보와 함께 푸쉬된 리소스를 전송 가능
      - 서버는 푸쉬되는 리소스의 우선 순위를 지정 가능
      - 클라이언트의 선택적 리소스 관리
  - Stream Prioritization
    - 클라이언트가 선호하는 응답 수신 방식을 지정해서 응답을 받을 수 있음 => 리소스간 의존 관계를 고려하여 우선 순위를 설정 
